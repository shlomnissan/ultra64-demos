			Textured Lighting
			     24jul95

This technique is an easy way to render bump-mapped surfaces.
The basic idea is that each face is drawn with a texture.
This texture is a Color-index texture, where the index corresponds
to one of a set of normal vectors.  This example uses 240 possible
normal vectors that tile a sphere. (Run sphd to see this tiling).

On a bumpy surface, the quantization of the normal vector into
a small number of possible normals averages out an the effect
should not be that noticeable.

Once the surface texture is computed, the Color Look-Up Table (CLUT)
must be computed by applying the lighting calculations to the
subset of normal vectors.  Note that the spherical tiling could be
finer in the direction of lights and coarser away from light, but
this isn't used at the moment.

So long as the object-light angles remain constant, the surface
will always be correctly lit, no matter where the viewer is
(assuming specularity has been ignored).  This approach also
assumes the surface material properties are constant and there
are not extra textures on the surface.

Mip-maps could be generated by suitable application of recursion
in the texture gereration function.  The will be left to future
developers.

NOTES:

Sphereical tiling:

A number of different approaches were considered.  The most
interesting was based on the dodecahedron.  Each pentagonal
face gets chopped into 5 equal triangles (project mid-point
to surface).  This generates 5*12=60 exactly identical triangles.
(Can you do better?)  Each of these is divided into 4 new
triangles.  The alpha of 0.5102 was determined to maximize the
surface area of the spherical approximation.  The normals
of the verticies are then averaged and normalized to create
the normal at the center of each face.  These center face normals
are the 240 normals used.

Lighting calculations:

These will be based on the flt2c tool.  Multiple lights and
even a specular term will be allowed.  Specularity assumes
a look direction, so highlights will be wrong if the look
direction changes too much.

Material properties:

Surface coloration is also part of the lighting calculation.
Each material will have a different response to lights.
A simple object description file will associate an object with
a material.

Bump Maps:

These can be in many different forms.  A simple one
is just the interpolated normal vectors (ala Phong
shading).  Additionally, there can be real bumps.
Real bumps have a center vector and a height profile
as a function of central angle (acos( phong_vect dot center)).
Bumps can be additive or obscuring.  Noise is an example
of additive bumps.  Also, a height-field can be used to
explicitly control the shape of more complex bumps.

Craters:

centeral normal
width
depth scale
slope noise (since craters are usually roughest
	     along steep areas.)

shape:         /\_
             _/   --_
\           /
 \       ---
  --x-w-/

Dimples are just craters with a smooth surface.

Pure noise can be added to the normals to get a sort of dithering
effect so that the quantization of normals won't be too visible.


UPDATE: 8aug95

Got first pass demo working.  Covered a 60 face bucky-ball
with 74 craters.  Craters are layed down in order, and newer
ones obscure older ones in their region of influence.  This
last part allows small craters to dig little holes in bigger
craters.  Crater shape is described by the "slope" of the
sides this is actaully a factor from -1 to 1 (scaled to
-128 to 127) determining how much of the "radial residual"
vector to add into the current normal.

The next step is to add dynamic lighting by recalculating the
lighting LUT each frame based on the angles of the lights and
the objects.  Maybe even allow multiple objects to re-use the
same geometry and surface textures, just change the LUT based
on its lighting and material color.
